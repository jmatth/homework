Josh Matthews

Compilers

Register Allocator Writeup


Algorithms
==========

Top-Down, No MAX_LIVE
---------------------

For this simple algorithm, the entire basic block was scanned and each register
had its occurrences counted. Those with the most occurrences were then allocated
physical registers up to the number of physical registers available minus the
size of the feasible set. Any remaining registers were spilled and loaded using
the feasible set.


Top-Down, MAX_LIVE
------------------

This algorithm is similar to the previous one, but takes registers live ranges
into account. To start the basic block is scanned and for each register it
calculates:

- its number of uses
- its live range

Additionally each line in the input file has the number of registers that are
live on it calculated. Each line is then visited in descending order of the
number of registers live on it. At each line:

- Then registers that are live on the line are sorted in order of total uses.
- The first (number of live registers) - (number of available physical
  registers) are spilled.
- The remaining registers are allocated to the available physical registers.

Once this calculation has been made for the entire file, the allocated program
is generated by inserting spill and load instructions as appropriate based on
how registers were marked during the previous phase.


Bottom-Up
---------

For this algorithm, only one pass was made on the input file, with physical
registers being allocated and freed along the way. As a consequence of virtual
registers always being allocated a physical register while in use, the size of
the feasible set was reduced by one. The allocation went as follows.

For each instruction:

- Check each input to the instruction:

  - If it is already loaded into a physical register, no extra work is needed.

  - If it has been spilled, allocate a physical register and insert code to load
    the spilled value into it.

- After the inputs are loaded, check if they are ever used again in the block.
  If they are not, mark the physical registers they are loaded into as free.

- For the output (if there is one), allocate it a physical register. This may be
  one of the same registers just used for the input if an input is never used
  again (see above).

The allocation algorithm is:

- If there is a physical register not holding a virtual register value, use it.

- Otherwise, find the physical register whose virtual register value is used the
  farthest in the future, or possibly never again. Insert code to spill this
  value to memory if it has not been spilled already, and then return the now
  available register for use.


Optimization: Enough Physical Registers:
----------------------------------------

An additional, simple algorithm was added for the special case where the target
architecture has enough physical registers to allocate one for each of the input
block's virtual registers. When this is the case, the allocator simply maps each
virtual register to a physical register, possibly using registers that would
other be part of the feasible set for spilling and loading to do so, and then
emits the resulting code. This algorithm is used whenever this case is detected
regardless of what the user specified as the allocation algorithm.

NOTE: This algorithm does not use `r0` to hold virtual register values, since it
is supposed "special". Therefor, this case is triggered when `(target
architecture registers) - 1 = (number of virtual registers`.
